<!DOCTYPE html>
<html>
<head>
    <title>Free GCLID Decoder Online & Function for Google Sheets</title>
    <meta name="description" content="Free GCLID Decoder Online & Function for Google Sheets">
    <link rel="canonical" href="https://www.martinaberastegue.com/free-gclid-decoder.html">
    <meta name="author" content="Martin Aberastegue">
    <meta name="robots" content="index, follow">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: #f8fafc; 
            min-height: 100vh;
            padding: 40px 20px;
        }
        .container { 
            max-width: 1300px; 
            margin: 0 auto; 
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        @media (max-width: 768px) {
            .container {
                margin: 20px;
                border-radius: 12px;
            }
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            text-align: center;
            color: white;
        }
        .header h1 {
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        .header p {
            font-size: 16px;
            opacity: 0.9;
        }
        .form-section {
            padding: 40px;
            border-bottom: 1px solid #e2e8f0;
        }
        .form-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .form-group label {
            font-weight: 500;
            color: #374151;
            font-size: 16px;
            min-width: 120px;
        }
        .input-wrapper {
            flex: 1;
            display: flex;
            gap: 12px;
        }
        input[type="text"] { 
            flex: 1;
            padding: 16px 20px; 
            font-size: 16px; 
            border: 2px solid #e2e8f0; 
            border-radius: 8px;
            transition: border-color 0.2s;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #0891b2;
        }
        button { 
            padding: 16px 24px; 
            background: #0891b2; 
            color: white; 
            border: none; 
            cursor: pointer; 
            border-radius: 8px; 
            font-size: 16px;
            font-weight: 500;
            transition: background 0.2s;
        }
        button:hover { 
            background: #0e7490; 
        }
        .result-section {
            padding: 40px;
            display: none;
        }
        .result-section.show {
            display: block;
        }
        .result-title {
            font-size: 24px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 20px;
        }
        .gclid-display {
            background: #f9fafb;
            padding: 18px 24px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            margin-bottom: 24px;
            word-break: break-all;
            font-family: Monaco, Consolas, 'Courier New', monospace;
            font-size: 14px;
            color: #374151;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .gclid-display strong {
            color: #1f2937;
            font-weight: 600;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-top: 24px;
        }
        @media (max-width: 1200px) {
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 18px;
            }
        }
        @media (max-width: 768px) {
            .metrics-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
        }
        .metric-card {
            border-radius: 12px;
            padding: 28px 20px;
            text-align: center;
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.06), 0 1px 2px 0 rgba(0, 0, 0, 0.04);
            transition: transform 0.2s, box-shadow 0.2s;
            border: 0;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .metric-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 15px 0 rgba(0, 0, 0, 0.08), 0 3px 6px 0 rgba(0, 0, 0, 0.04);
        }
        .metric-card:nth-child(1) {
            background: linear-gradient(135deg, #fef3f2 0%, #fecaca 100%);
            border-left: 4px solid #f87171;
        }
        .metric-card:nth-child(2) {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border-left: 4px solid #60a5fa;
        }
        .metric-card:nth-child(3) {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border-left: 4px solid #4ade80;
        }
        .metric-card:nth-child(4) {
            background: linear-gradient(135deg, #fefce8 0%, #fef3c7 100%);
            border-left: 4px solid #facc15;
        }
        .metric-card h3 {
            font-size: 11px;
            font-weight: 700;
            color: #6b7280;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .metric-card .value {
            font-size: 16px;
            font-weight: 700;
            color: #111827;
            line-height: 1.2;
            word-break: break-word;
            hyphens: auto;
        }
        @media (max-width: 768px) {
            .metric-card .value {
                font-size: 14px;
            }
            .metric-card h3 {
                font-size: 10px;
            }
        }
        .error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .no-timestamps {
            background: #fffbeb;
            border: 1px solid #fed7aa;
            color: #d97706;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .explanation-section {
            padding: 40px;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            border-top: 1px solid #cbd5e1;
        }
        .explanation-title {
            font-size: 28px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 32px;
            text-align: center;
        }
        .explanation-content {
            max-width: 1000px;
            margin: 0 auto;
        }
        .explanation-block {
            background: white;
            border-radius: 12px;
            padding: 32px;
            margin-bottom: 24px;
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid #e5e7eb;
        }
        .explanation-block h3 {
            font-size: 20px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 16px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 8px;
        }
        .explanation-block p {
            font-size: 16px;
            line-height: 1.6;
            color: #4b5563;
            margin-bottom: 16px;
        }
        .step {
            margin: 24px 0;
            border-left: 4px solid #0891b2;
            padding-left: 20px;
        }
        .step h4 {
            font-size: 18px;
            font-weight: 600;
            color: #0891b2;
            margin-bottom: 12px;
        }
        .step p {
            margin-bottom: 16px;
        }
        .code-block {
            background: #1f2937;
            border-radius: 8px;
            overflow-x: auto;
            margin: 16px 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .code-block pre {
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }
        .code-block code {
            font-family: Monaco, Consolas, 'SF Mono', 'Roboto Mono', monospace;
            font-size: 14px;
            line-height: 1.4;
            color: #e5e7eb;
            white-space: pre;
        }
        .explanation-block ul {
            list-style-type: none;
            padding: 0;
        }
        .explanation-block li {
            font-size: 16px;
            line-height: 1.6;
            color: #4b5563;
            margin-bottom: 12px;
            padding-left: 24px;
            position: relative;
        }
        .explanation-block li:before {
            content: "â†’";
            position: absolute;
            left: 0;
            color: #0891b2;
            font-weight: bold;
        }
        .explanation-block li strong {
            color: #1f2937;
            font-weight: 600;
        }
        
        /* Google Sheets Section Styles */
        .google-sheets-section {
            background: linear-gradient(135deg, #e8f5e8 0%, #f0f9ff 100%);
            border: 2px solid #10b981;
            border-radius: 16px;
            margin-bottom: 32px;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .sheets-toggle {
            cursor: pointer;
            padding: 24px 32px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            margin: 0;
            transition: background 0.3s ease;
            border: none;
            width: 100%;
            text-align: left;
        }
        
        .sheets-toggle:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }
        
        .sheets-toggle .explanation-title {
            color: white;
            margin: 0;
            font-size: 24px;
        }
        
        .toggle-icon {
            font-size: 18px;
            font-weight: bold;
            transition: transform 0.3s ease;
        }
        
        .google-sheets-section.open .toggle-icon {
            transform: rotate(180deg);
        }
        
        .sheets-content {
            padding: 32px;
            background: white;
            display: none;
        }
        
        .google-sheets-section.open .sheets-content {
            display: block;
        }
        
        .setup-steps {
            margin-top: 24px;
        }
        
        .formula-examples {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin: 20px 0;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .formula-item {
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }
        
        .formula-item code {
            display: block;
            font-family: Monaco, Consolas, 'SF Mono', 'Roboto Mono', monospace;
            font-size: 13px;
            color: #059669;
            background: #f0f9ff;
            padding: 6px 8px;
            border-radius: 4px;
            margin-top: 8px;
            border: 1px solid #bae6fd;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 20px;
                border-radius: 12px;
            }
            .formula-examples {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .sheets-toggle {
                padding: 20px 24px;
                flex-direction: column;
                text-align: center;
                gap: 12px;
            }
            
            .sheets-content {
                padding: 24px 20px;
            }
            .explanation-section {
                margin: 20px;
                padding: 24px 20px;
                border-radius: 12px;
            }
            .explanation-block {
                padding: 20px;
            }
            .explanation-title {
                font-size: 24px;
            }
            .explanation-block h3 {
                font-size: 18px;
            }
            .step {
                padding-left: 16px;
            }
            .code-block pre {
                padding: 16px;
                font-size: 12px;
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>GCLID Decoder</h1>
            <p>Extract timestamps and decode Google Click IDs</p>
        </div>
        
        <div class="form-section">
            <div class="form-group">
                <label>Google Click ID</label>
                <div class="input-wrapper">
                    <input type="text" id="gclidInput" 
                           placeholder="e.g., CjwKCAjw9uPCBhATEiwABHN9K2B9F4HWFkzGiAM0475q8uywtcmQIKSg8rGUU2VLTgmubUF6wCQJtxoCmp8QAvD_BwE">
                    <button onclick="decodeGclid()">Decode GCLID</button>
                </div>
            </div>
        </div>
        
        <div class="result-section" id="resultSection">
            <h2 class="result-title">Result</h2>
            
            <div class="gclid-display" id="gclidDisplay"></div>
            
            <div id="resultContent"></div>
        </div>
        
        <!-- Google Sheets Section -->
        <div class="explanation-section">
            <div class="google-sheets-section" id="googleSheetsSection">
                <button class="sheets-toggle" onclick="toggleSheetsSection()">
                    <h2 class="explanation-title">ðŸ“Š Decode this in Google Sheets</h2>
                    <span class="toggle-icon">â–¼</span>
                </button>
                
                <div class="sheets-content">
                    <div class="explanation-block">
                        <h3>Custom Google Sheets Formula</h3>
                        <p>Use our custom Google Apps Script to decode GCLIDs directly in Google Sheets with simple formulas like <code>=GCLID_TIMESTAMP(A1)</code></p>
                        
                        <div class="setup-steps">
                            <div class="step">
                                <h4>1. Open Your Google Sheet & Add Script</h4>
                                <p>In your Google Sheet, go to <strong>Extensions</strong> â†’ <strong>Apps Script</strong> (or <strong>Tools</strong> â†’ <strong>Script editor</strong> in older versions)</p>
                                <p>Delete the default <code>function myFunction() {}</code> and replace with:</p>
                            </div>
                            
                            <div class="code-block">
<pre><code>/**
 * GCLID Decoder for Google Sheets by Martin Aberastegue
 * https://www.martinaberastegue.com/
 * Custom function to extract timestamps from Google Click IDs
 * 
 * Usage in Google Sheets:
 * =GCLID_TIMESTAMP("your_gclid_here")
 * =GCLID_TIMESTAMP("your_gclid_here", "gmt") - for GMT format
 * =GCLID_TIMESTAMP("your_gclid_here", "local") - for local format
 * =GCLID_TIMESTAMP("your_gclid_here", "unix") - for Unix timestamp
 */

/**
 * Extract timestamp from GCLID
 * @param {string} gclid The Google Click ID to decode
 * @param {string} format Optional format: "unix", "gmt", "local" (default: "local")
 * @return {string|number} The extracted timestamp in requested format
 * @customfunction
 */
function GCLID_TIMESTAMP(gclid, format = "local") {
  try {
    if (!gclid || typeof gclid !== 'string') {
      return "ERROR: Invalid GCLID";
    }
    
    // Clean the GCLID
    gclid = gclid.trim();
    
    // Decode from base64url
    const binary = base64urlDecode(gclid);
    if (!binary) {
      return "ERROR: Invalid base64url encoding";
    }
    
    // Parse as protobuf
    const data = parseProtobuf(binary);
    
    // Extract timestamps
    const timestamps = extractTimestamps(data);
    
    if (timestamps.length === 0) {
      return "ERROR: No timestamp found";
    }
    
    const timestamp = timestamps[0];
    
    // Return in requested format
    switch (format.toLowerCase()) {
      case "unix":
        return timestamp.unix_timestamp;
      case "gmt":
        return timestamp.gmt_date;
      case "local":
      default:
        return timestamp.local_date;
    }
    
  } catch (error) {
    return "ERROR: " + error.message;
  }
}

/**
 * Get all GCLID information as JSON
 * @param {string} gclid The Google Click ID to decode
 * @return {string} JSON string with all extracted information
 * @customfunction
 */
function GCLID_INFO(gclid) {
  try {
    if (!gclid || typeof gclid !== 'string') {
      return "ERROR: Invalid GCLID";
    }
    
    gclid = gclid.trim();
    const binary = base64urlDecode(gclid);
    if (!binary) {
      return "ERROR: Invalid base64url encoding";
    }
    
    const data = parseProtobuf(binary);
    const timestamps = extractTimestamps(data);
    
    const result = {
      gclid: gclid,
      char_length: gclid.length,
      timestamps: timestamps,
      raw_data: data
    };
    
    return JSON.stringify(result, null, 2);
    
  } catch (error) {
    return "ERROR: " + error.message;
  }
}

/**
 * Decode base64url string to Uint8Array
 */
function base64urlDecode(data) {
  try {
    // Add padding if needed
    const remainder = data.length % 4;
    if (remainder) {
      data += '='.repeat(4 - remainder);
    }
    
    // Convert base64url to base64
    data = data.replace(/-/g, '+').replace(/_/g, '/');
    
    // Decode base64 to blob, then get bytes
    const blob = Utilities.base64Decode(data);
    
    // Convert blob to Uint8Array
    const bytes = new Uint8Array(blob.length);
    for (let i = 0; i < blob.length; i++) {
      bytes[i] = blob[i] & 0xFF; // Ensure byte value
    }
    
    return bytes;
  } catch (e) {
    // Fallback method using manual base64 decoding
    return manualBase64Decode(data);
  }
}

/**
 * Manual base64 decoding fallback
 */
function manualBase64Decode(data) {
  try {
    // Add padding if needed
    const remainder = data.length % 4;
    if (remainder) {
      data += '='.repeat(4 - remainder);
    }
    
    // Convert base64url to base64
    data = data.replace(/-/g, '+').replace(/_/g, '/');
    
    // Base64 decode table
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    const lookup = {};
    for (let i = 0; i < chars.length; i++) {
      lookup[chars[i]] = i;
    }
    
    const bytes = [];
    for (let i = 0; i < data.length; i += 4) {
      const a = lookup[data[i]] || 0;
      const b = lookup[data[i + 1]] || 0;
      const c = lookup[data[i + 2]] || 0;
      const d = lookup[data[i + 3]] || 0;
      
      const bitmap = (a << 18) | (b << 12) | (c << 6) | d;
      
      bytes.push((bitmap >> 16) & 255);
      if (data[i + 2] !== '=') bytes.push((bitmap >> 8) & 255);
      if (data[i + 3] !== '=') bytes.push(bitmap & 255);
    }
    
    return new Uint8Array(bytes);
  } catch (e) {
    return null;
  }
}

/**
 * Parse protobuf binary data
 */
function parseProtobuf(data) {
  const result = {};
  let offset = 0;
  const length = data.length;
  
  while (offset < length) {
    // Read field header (tag + wire type)
    const varintResult = decodeVarint(data, offset);
    if (!varintResult) break;
    
    const header = varintResult.value;
    offset = varintResult.offset;
    
    const fieldNumber = header >> 3;
    const wireType = header & 0x7;
    
    switch (wireType) {
      case 0: // varint
        const varintFieldResult = decodeVarint(data, offset);
        if (varintFieldResult) {
          result[fieldNumber] = varintFieldResult.value;
          offset = varintFieldResult.offset;
        }
        break;
        
      case 1: // 64-bit
        if (offset + 8 <= length) {
          result[fieldNumber] = data.slice(offset, offset + 8);
          offset += 8;
        }
        break;
        
      case 2: // length-delimited
        const lengthResult = decodeVarint(data, offset);
        if (lengthResult) {
          const fieldLength = lengthResult.value;
          offset = lengthResult.offset;
          
          if (offset + fieldLength <= length) {
            const fieldData = data.slice(offset, offset + fieldLength);
            
            // Try to parse as nested protobuf
            try {
              const nested = parseProtobuf(fieldData);
              if (Object.keys(nested).length > 0) {
                result[fieldNumber] = nested;
              } else {
                result[fieldNumber] = fieldData;
              }
            } catch (e) {
              result[fieldNumber] = fieldData;
            }
            offset += fieldLength;
          }
        }
        break;
        
      case 5: // 32-bit
        if (offset + 4 <= length) {
          result[fieldNumber] = data.slice(offset, offset + 4);
          offset += 4;
        }
        break;
        
      default:
        // Unknown wire type, skip
        offset++;
        break;
    }
  }
  
  return result;
}

/**
 * Decode varint from binary data
 */
function decodeVarint(data, offset) {
  const length = data.length;
  let value = 0;
  let shift = 0;
  
  while (offset < length) {
    const byte = data[offset];
    offset++;
    
    // Extract the 7 data bits
    const dataBits = byte & 0x7F;
    
    // Add to result
    value += dataBits * Math.pow(2, shift);
    
    // If MSB is not set, we're done
    if ((byte & 0x80) === 0) {
      return { value: value, offset: offset };
    }
    
    shift += 7;
    
    // Prevent infinite loops
    if (shift >= 64) {
      return null;
    }
  }
  
  return null;
}

/**
 * Extract timestamps from parsed protobuf data
 */
function extractTimestamps(data) {
  const timestamps = [];
  extractTimestampsRecursive(data, timestamps);
  
  // Convert to readable format
  const readable = [];
  for (const ts of timestamps) {
    let unixTimestamp = null;
    
    if (ts > 1000000000 && ts < 2000000000) {
      // Unix timestamp in seconds
      unixTimestamp = ts;
    } else if (ts > 1000000000000 && ts < 2000000000000) {
      // Unix timestamp in milliseconds
      unixTimestamp = ts / 1000;
    } else if (ts > 1000000000000000) {
      // Unix timestamp in microseconds
      unixTimestamp = ts / 1000000;
    }
    
    if (unixTimestamp) {
      const date = new Date(unixTimestamp * 1000);
      const timestampInfo = {
        original: ts,
        unix_timestamp: unixTimestamp,
        gmt_date: date.toISOString().replace('T', ' ').replace('.000Z', ' GMT'),
        local_date: date.toLocaleString()
      };
      
      // Avoid duplicates
      if (!readable.some(r => r.original === ts)) {
        readable.push(timestampInfo);
      }
    }
  }
  
  return readable;
}

/**
 * Recursively extract numeric values that could be timestamps
 */
function extractTimestampsRecursive(data, timestamps) {
  if (Array.isArray(data)) {
    for (const value of data) {
      extractTimestampsRecursive(value, timestamps);
    }
  } else if (typeof data === 'object' && data !== null) {
    for (const key in data) {
      extractTimestampsRecursive(data[key], timestamps);
    }
  } else if (typeof data === 'number' && data > 1000000000) {
    timestamps.push(data);
  }
}</code></pre>
                            </div>
                            
                            <div class="step">
                                <h4>2. Save the Script</h4>
                                <p>Click the <strong>Save</strong> button (ðŸ’¾) or press <strong>Ctrl+S</strong> (Cmd+S on Mac)</p>
                                <p>Give it a name like "GCLID Decoder" when prompted</p>
                            </div>
                            
                            <div class="step">
                                <h4>3. Use the Formulas</h4>
                                <p>Go back to your Google Sheet and use these formulas in any cell:</p>
                                <div class="formula-examples">
                                    <div class="formula-item">
                                        <strong>Basic timestamp:</strong><br>
                                        <code>=GCLID_TIMESTAMP(A1)</code>
                                    </div>
                                    <div class="formula-item">
                                        <strong>Unix timestamp:</strong><br>
                                        <code>=GCLID_TIMESTAMP(A1, "unix")</code>
                                    </div>
                                    <div class="formula-item">
                                        <strong>GMT format:</strong><br>
                                        <code>=GCLID_TIMESTAMP(A1, "gmt")</code>
                                    </div>
                                    <div class="formula-item">
                                        <strong>Complete info:</strong><br>
                                        <code>=GCLID_INFO(A1)</code>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="step">
                                <h4>4. Bulk Processing</h4>
                                <p>Put your GCLIDs in column A, use <code>=GCLID_TIMESTAMP(A1)</code> in column B, then drag the formula down to process multiple GCLIDs at once!</p>
                                <p><strong>ðŸ’¡ Pro tip:</strong> The custom functions are now available in this sheet and any new sheets you create in this Google Sheets file.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- How It Works Section -->
        <div class="explanation-section">
            <h2 class="explanation-title">How GCLID Decoding Works</h2>
            
            <div class="explanation-content">
                <div class="explanation-block">
                    <h3>What is GCLID?</h3>
                    <p>GCLID (Google Click Identifier) is a unique tracking parameter that Google Ads appends to URLs when someone clicks on your ad. It contains encoded information including timestamps, campaign data, and other tracking metadata encoded in Protocol Buffers (protobuf) format.</p>
                </div>
                
                <div class="explanation-block">
                    <h3>Decoding Process</h3>
                    <p>This decoder is based on my original PHP implementation, which I later adapted to JavaScript for browser compatibility and Google Apps Script for Google Sheets integration. The core decoding logic remains the same across all three implementations. For this explanation, I'll show you the PHP code since it's the most readable and well-documented version.</p>
                    <p>The decoding happens in 4 main steps:</p>
                    
                    <div class="step">
                        <h4>1. Base64URL Decoding</h4>
                        <p>GCLID uses base64url encoding (URL-safe base64). We first convert it to binary data:</p>
                        <div class="code-block">
<pre><code>function base64urlDecode(data) {
    // Add padding if needed
    const remainder = data.length % 4;
    if (remainder) {
        data += '='.repeat(4 - remainder);
    }
    
    // Convert base64url to base64
    data = data.replace(/-/g, '+').replace(/_/g, '/');
    
    // Decode base64 to binary
    const binaryString = atob(data);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    
    return bytes;
}</code></pre>
                        </div>
                    </div>
                    
                    <div class="step">
                        <h4>2. Protocol Buffers Parsing</h4>
                        <p>The binary data is structured as protobuf messages. We parse each field using wire types:</p>
                        <div class="code-block">
<pre><code>function parseProtobuf(data) {
    const result = {};
    let offset = 0;
    const length = data.length;
    
    while (offset < length) {
        // Read field header (tag + wire type)
        const varintResult = decodeVarint(data, offset);
        const header = varintResult.value;
        offset = varintResult.offset;
        
        const fieldNumber = header >> 3;
        const wireType = header & 0x7;
        
        switch (wireType) {
            case 0: // varint (timestamps often here)
            case 1: // 64-bit
            case 2: // length-delimited (nested data)
            case 5: // 32-bit
        }
    }
    
    return result;
}</code></pre>
                        </div>
                    </div>
                    
                    <div class="step">
                        <h4>3. Varint Decoding</h4>
                        <p>Protobuf uses variable-length integers (varints) for efficient encoding. Each byte uses 7 bits for data and 1 bit as continuation flag:</p>
                        <div class="code-block">
<pre><code>function decodeVarint(data, offset) {
    let value = 0;
    let shift = 0;
    
    while (offset < data.length) {
        const byte = data[offset];
        offset++;
        
        // Extract the 7 data bits
        const dataBits = byte & 0x7F;
        
        // Add to result
        value += dataBits * Math.pow(2, shift);
        
        // If MSB is not set, we're done
        if ((byte & 0x80) === 0) {
            return { value: value, offset: offset };
        }
        
        shift += 7;
    }
}</code></pre>
                        </div>
                    </div>
                    
                    <div class="step">
                        <h4>4. Timestamp Extraction</h4>
                        <p>We recursively search for numeric values that look like Unix timestamps and convert them to readable dates:</p>
                        <div class="code-block">
<pre><code>function extractTimestamps(data) {
    const timestamps = [];
    extractTimestampsRecursive(data, timestamps);
    
    const readable = [];
    for (const ts of timestamps) {
        let unixTimestamp = null;
        
        if (ts > 1000000000 && ts < 2000000000) {
            // Unix timestamp in seconds
            unixTimestamp = ts;
        } else if (ts > 1000000000000 && ts < 2000000000000) {
            // Unix timestamp in milliseconds  
            unixTimestamp = ts / 1000;
        } else if (ts > 1000000000000000) {
            // Unix timestamp in microseconds
            unixTimestamp = ts / 1000000;
        }
        
        if (unixTimestamp) {
            const date = new Date(unixTimestamp * 1000);
            const timestampInfo = {
                original: ts,
                unix_timestamp: unixTimestamp,
                gmt_date: date.toISOString().replace('T', ' ').replace('.000Z', ' GMT'),
                local_date: date.toLocaleString()
            };
            readable.push(timestampInfo);
        }
    }
    
    return readable;
}</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="explanation-block">
                    <h3>What Information Can Be Extracted?</h3>
                    <ul>
                        <li><strong>Click Timestamp:</strong> When the ad was clicked (in various precisions)</li>
                        <li><strong>Campaign Data:</strong> Internal Google Ads campaign identifiers</li>
                        <li><strong>Attribution Data:</strong> Information for conversion tracking</li>
                        <li><strong>Session Data:</strong> Browser session and user interaction data</li>
                    </ul>
                </div>
                
                <div class="explanation-block">
                    <h3>Technical Details</h3>
                    <ul>
                        <li><strong>Encoding:</strong> Base64URL â†’ Binary â†’ Protocol Buffers</li>
                        <li><strong>Wire Types:</strong> 0=varint, 1=64bit, 2=length-delimited, 5=32bit</li>
                        <li><strong>Timestamp Formats:</strong> Unix seconds, milliseconds, or microseconds</li>
                        <li><strong>Nested Messages:</strong> Recursive parsing for complex data structures</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * GCLID Decoder based on proven varint implementations
         * Inspired by chrisdickinson/varint and pawitp/protobuf-decoder
         * Author: Martin Aberastegue
         * https://www.martinaberastegue.com/
         */

        function gclidDecode(gclid) {
            try {
                // Clean the GCLID
                gclid = gclid.trim();
                
                // Decode from base64url
                const binary = base64urlDecode(gclid);
                if (!binary) {
                    return { error: 'Invalid base64url encoding' };
                }
                
                // Parse as protobuf
                const data = parseProtobuf(binary);
                return data;
                
            } catch (e) {
                return { error: e.message };
            }
        }

        function base64urlDecode(data) {
            try {
                // Add padding if needed
                const remainder = data.length % 4;
                if (remainder) {
                    data += '='.repeat(4 - remainder);
                }
                
                // Convert base64url to base64
                data = data.replace(/-/g, '+').replace(/_/g, '/');
                
                // Decode base64 to binary
                const binaryString = atob(data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                return bytes;
            } catch (e) {
                return null;
            }
        }

        function parseProtobuf(data) {
            const result = {};
            let offset = 0;
            const length = data.length;
            
            while (offset < length) {
                // Read field header (tag + wire type)
                const varintResult = decodeVarint(data, offset);
                if (!varintResult) break;
                
                const header = varintResult.value;
                offset = varintResult.offset;
                
                const fieldNumber = header >> 3;
                const wireType = header & 0x7;
                
                switch (wireType) {
                    case 0: // varint
                        const varintFieldResult = decodeVarint(data, offset);
                        if (varintFieldResult) {
                            result[fieldNumber] = varintFieldResult.value;
                            offset = varintFieldResult.offset;
                        }
                        break;
                        
                    case 1: // 64-bit
                        if (offset + 8 <= length) {
                            result[fieldNumber] = data.slice(offset, offset + 8);
                            offset += 8;
                        }
                        break;
                        
                    case 2: // length-delimited
                        const lengthResult = decodeVarint(data, offset);
                        if (lengthResult) {
                            const fieldLength = lengthResult.value;
                            offset = lengthResult.offset;
                            
                            if (offset + fieldLength <= length) {
                                const fieldData = data.slice(offset, offset + fieldLength);
                                
                                // Try to parse as nested protobuf
                                try {
                                    const nested = parseProtobuf(fieldData);
                                    if (Object.keys(nested).length > 0) {
                                        result[fieldNumber] = nested;
                                    } else {
                                        result[fieldNumber] = fieldData;
                                    }
                                } catch (e) {
                                    result[fieldNumber] = fieldData;
                                }
                                offset += fieldLength;
                            }
                        }
                        break;
                        
                    case 5: // 32-bit
                        if (offset + 4 <= length) {
                            result[fieldNumber] = data.slice(offset, offset + 4);
                            offset += 4;
                        }
                        break;
                        
                    default:
                        // Unknown wire type, skip
                        offset++;
                        break;
                }
            }
            
            return result;
        }

        function decodeVarint(data, offset) {
            const length = data.length;
            let value = 0;
            let shift = 0;
            
            while (offset < length) {
                const byte = data[offset];
                offset++;
                
                // Extract the 7 data bits
                const dataBits = byte & 0x7F;
                
                // Add to result
                value += dataBits * Math.pow(2, shift);
                
                // If MSB is not set, we're done
                if ((byte & 0x80) === 0) {
                    return { value: value, offset: offset };
                }
                
                shift += 7;
                
                // Prevent infinite loops
                if (shift >= 64) {
                    return null;
                }
            }
            
            return null;
        }

        function extractTimestamps(data) {
            const timestamps = [];
            extractTimestampsRecursive(data, timestamps);
            
            // Convert to readable format with timestamp, GMT, and local timezone
            const readable = [];
            const seen = new Set();
            
            for (const ts of timestamps) {
                if (seen.has(ts)) continue;
                seen.add(ts);
                
                let unixTimestamp = null;
                
                if (ts > 1000000000 && ts < 2000000000) {
                    // Unix timestamp in seconds
                    unixTimestamp = ts;
                } else if (ts > 1000000000000 && ts < 2000000000000) {
                    // Unix timestamp in milliseconds  
                    unixTimestamp = ts / 1000;
                } else if (ts > 1000000000000000) {
                    // Unix timestamp in microseconds
                    unixTimestamp = ts / 1000000;
                }
                
                if (unixTimestamp) {
                    const date = new Date(unixTimestamp * 1000);
                    
                    // Format GMT date as DD-MM-YYYY HH:mm:ss GMT
                    const gmtDate = new Date(date.getTime());
                    const gmtFormatted = `${String(gmtDate.getUTCDate()).padStart(2, '0')}-${String(gmtDate.getUTCMonth() + 1).padStart(2, '0')}-${gmtDate.getUTCFullYear()} ${String(gmtDate.getUTCHours()).padStart(2, '0')}:${String(gmtDate.getUTCMinutes()).padStart(2, '0')}:${String(gmtDate.getUTCSeconds()).padStart(2, '0')} GMT`;
                    
                    // Format local date as DD-MM-YYYY HH:mm:ss TIMEZONE
                    const localFormatted = `${String(date.getDate()).padStart(2, '0')}-${String(date.getMonth() + 1).padStart(2, '0')}-${date.getFullYear()} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')} ${date.toLocaleTimeString('en-US', {timeZoneName: 'short'}).split(' ')[2] || 'Local'}`;
                    
                    const timestampInfo = {
                        original: ts,
                        unix_timestamp: unixTimestamp,
                        gmt_date: gmtFormatted,
                        local_date: localFormatted
                    };
                    
                    readable.push(timestampInfo);
                }
            }
            
            return readable;
        }

        function extractTimestampsRecursive(data, timestamps) {
            if (Array.isArray(data)) {
                for (const value of data) {
                    extractTimestampsRecursive(value, timestamps);
                }
            } else if (typeof data === 'object' && data !== null) {
                for (const key in data) {
                    extractTimestampsRecursive(data[key], timestamps);
                }
            } else if (typeof data === 'number' && data > 1000000000) {
                timestamps.push(data);
            }
        }

        function decodeGclid() {
            const gclidInput = document.getElementById('gclidInput');
            const resultSection = document.getElementById('resultSection');
            const gclidDisplay = document.getElementById('gclidDisplay');
            const resultContent = document.getElementById('resultContent');
            
            const gclid = gclidInput.value.trim();
            
            if (!gclid) {
                alert('Please enter a GCLID');
                return;
            }
            
            // Show GCLID
            gclidDisplay.innerHTML = `<strong>GCLID : </strong>${gclid}`;
            
            // Decode GCLID
            const result = gclidDecode(gclid);
            
            if (result.error) {
                resultContent.innerHTML = `<div class="error">Error: ${result.error}</div>`;
            } else {
                const timestamps = extractTimestamps(result);
                
                if (timestamps.length > 0) {
                    const tsInfo = timestamps[0]; // Get first timestamp
                    const charLength = gclid.length;
                    
                    resultContent.innerHTML = `
                        <div class="metrics-grid">
                            <div class="metric-card">
                                <h3>Char Length</h3>
                                <div class="value">${charLength}</div>
                            </div>
                            <div class="metric-card">
                                <h3>Timestamp</h3>
                                <div class="value">${tsInfo.original}</div>
                            </div>
                            <div class="metric-card">
                                <h3>GMT Date</h3>
                                <div class="value">${tsInfo.gmt_date}</div>
                            </div>
                            <div class="metric-card">
                                <h3>Local Date (Your timezone)</h3>
                                <div class="value">${tsInfo.local_date}</div>
                            </div>
                        </div>
                    `;
                } else {
                    resultContent.innerHTML = `<div class="no-timestamps">No timestamps found in this GCLID</div>`;
                }
            }
            
            resultSection.classList.add('show');
        }

        // Allow Enter key to trigger decode
        document.getElementById('gclidInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                decodeGclid();
            }
        });

        // Toggle Google Sheets section
        function toggleSheetsSection() {
            const section = document.getElementById('googleSheetsSection');
            section.classList.toggle('open');
        }

        // Example GCLID for testing
        document.addEventListener('DOMContentLoaded', function() {
            // You can uncomment this line to pre-fill with an example GCLID for testing
            // document.getElementById('gclidInput').value = 'CjwKCAjw9uPCBhATEiwABHN9K2B9F4HWFkzGiAM0475q8uywtcmQIKSg8rGUU2VLTgmubUF6wCQJtxoCmp8QAvD_BwE';
        });
    </script>
</body>
</html> 